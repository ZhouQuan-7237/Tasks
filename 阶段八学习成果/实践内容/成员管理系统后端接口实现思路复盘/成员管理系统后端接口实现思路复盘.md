# 成员管理系统后端接口实现思路复盘——周全

## 整体目录

1. 需求分析
   1. 任务分析
   2. 所需结构体
   3. 所需函数
   4. 数据表结构
   5. 所需路由
   6. 权限管理
   7. 安全方面 

2. 技术选型
   1. bcrypt算法
   2. json格式
3. 项目结构
   1. 简略/详细
   2. 设计思路
   3. 技术路线
   4. 参考资料

4. 实现步骤
   1. 初始化项目
   2. 配置数据库
   3. 定义用户模型
   4. 处理业务逻辑
   5. 配置相关路由
   6. 处理中间件
   7. 密码加密存储

## 具体内容

### 一. 需求分析

#### 1. 任务分析

**分析思路：从任务要求出发，逐步解析需求，并细化成具体的功能模块和技术实现**



成员管理系统的所有后端接口，实现内容：

- 用户包括 —— 管理员和普通用户`需要创建一个user表存储用户信息，所以需要创建一个User结构体与之对应`

  `同时需要用字段is_admin区分两类用户，普通用户默认is_admin=false，管理员is_admin=true`

- 用户注册和登录`需要有Register函数和Login函数（公有）`

  用户信息包括用户ID、密码（数据库中加密）、昵称、手机号、邮箱地址

  ```bash
  所以我需要
  1.创建一个RegisterRequest结构体，规定注册时的请求结构
  2.创建一个LoginRequest结构体，规定登录时的请求结构
  3.同时还需要用到JWT身份验证和密码加密存储
  4.数据表字段需要有user_id、password、nickname、phone、email
  
  同时用户注册登录过程中涉及到前后端数据的交互，所以需要确定数据的格式，确保前后端能正确解析和处理请求数据
  ```

- 管理员

  - 删除普通用户`需要有DeleteUser函数（管理员私有）`

  - 获取一个成员信息`需要有GetUser函数（管理员私有）`

  - 获取所有成员信息`需要有GetAllUsers函数（管理员私有）`

  - 审核新用户注册信息`需要有ApproveUser函数（管理员私有）`

    `数据表需用字段is_approved区分是否审核是否通过，普通用户注册后默认is_approved=false,需要经过管理员审核后is_approved=true`

- 普通用户

  - 更改个人信息`需要有UpdateUser函数（私有）`

#### 2. 所需结构体

| 结构体          | 说明             |
| --------------- | ---------------- |
| User            | 定义数据库表结构 |
| RegisterRequest | 定义注册请求结构 |
| LoginRequest    | 定义登录请求结构 |

#### 3. 所需函数

| 角色         | 功能          | 方法         |
| ------------ | ------------- | ------------ |
| 公有（用户） | `Register`    | 注册         |
|              | `Login`       | 登录         |
|              | `UpdateUser`  | 修改个人信息 |
| 管理员       | `DeleteUser`  | 删除用户     |
|              | `GetUser`     | 获取单个用户 |
|              | `GetAllUsers` | 获取所有用户 |
|              | `ApproveUser` | 审核用户     |

#### 4. 数据表结构

| 字段          | 类型     | 说明                       |
| ------------- | -------- | -------------------------- |
| `id`          | `uint`   | 主键，自增                 |
| `user_id`     | `string` | 用户名，唯一不可重复       |
| `password`    | `string` | 加密存储密码               |
| `nickname`    | `string` | 昵称                       |
| `phone`       | `string` | 手机号                     |
| `email`       | `string` | 邮箱                       |
| `is_admin`    | `bool`   | 是否管理员，默认 `false`   |
| `is_approved` | `bool`   | 是否审核通过，默认 `false` |

#### 5. 所需路由

| 方法     | 路由路径             | 对应接口           | 处理函数      | 角色     | 说明                               |
| -------- | -------------------- | ------------------ | ------------- | -------- | ---------------------------------- |
| `POST`   | `/register`          | 注册接口           | `Register`    | 任何人   | 用户注册                           |
| `POST`   | `/login`             | 登录接口           | `Login`       | 任何人   | 用户登录                           |
| `PUT`    | `/user/profile`      | 更新用户的接口     | `UpdateUser`  | 普通用户 | 修改个人信息（ 需要JWT认证）       |
| `GET`    | `/users/:id`         | 获取单个用户的接口 | `GetUser`     | 管理员   | 获取单个用户信息（需要管理员权限） |
| `GET`    | `/users`             | 获取所有用户的接口 | `GetAllUsers` | 管理员   | 获取所有用户（需要管理员权限）     |
| `PUT`    | `/users/:id/approve` | 审核用户的接口     | `ApproveUser` | 管理员   | 审核用户（需要管理员权限）         |
| `DELETE` | `/users/:id`         | 删除用户的接口     | `DeleteUser`  | 管理员   | 删除普通用户（需要管理员权限）     |

#### 6. 权限管理

* **用户管理**

  - 需要存储用户信息

  - 通过 `is_admin` 字段区分管理员和普通用户

  - 通过 `is_approved` 字段管理审核状态
  - 普通用户注册后默认`is_admin=false`

  - 普通用户注册后默认 `is_approved=false`，需要管理员审核

* **权限控制**

  * 普通用户访问API

    * 需要 `JWT 认证`（必须登录）

    * 只能修改自己的信息

  - 管理员访问API

    * 需要 `JWT 认证`（必须登录）

    * 需要 **`is_admin=true`**（必须是管理员）

    * 能操作所有用户

* **前后端交互**

  * 需要选择一种数据交互的格式

#### 7. 安全方面

* **密码存储**——需要使用一种算法进行加密

* **JWT认证**
* 用户登录成功后，返回 JWT 令牌
  
* 访问 API 时，必须在 `Authorization` 头部附带 `Bearer token`

---

### 二. 技术选型

**选择思路：根据需求分析选择合适的技术**



| 需求       | 选用技术               |
| ---------- | ---------------------- |
| Web 框架   | Gin（轻量高效）        |
| 数据库     | MySQL（存储用户数据）  |
| ORM        | GORM（简化数据库操作） |
| 身份认证   | JWT（基于 Token 认证） |
| 密码加密   | Bcrypt（安全加密存储） |
| API 设计   | RESTful（规范化接口）  |
| 前后端交互 | JSON（轻量便用）       |



这里的`Bcrypt加密算法`、`JSON数据格式`是需要额外学习的技术

#### 1. Bcrypt加密算法

##### 1.1 选择原因：安全性高

参考资料：

[存储用户密码应该使用什么加密算法？比较合适](https://blog.csdn.net/m0_49496327/article/details/124353932)

[最安全的hash 算法 - Bcrypt](https://juejin.cn/post/7227000656602890295)

##### 1.2 技术路线

在CSDN上搜` Bcrypt在go中的使用` ,阅读相关博客，学习相关代码

参考资料：

[Go 使用bcrypt实现密码加密和和校验](https://blog.csdn.net/qq_39335595/article/details/139095268?ops_request_misc=&request_id=&biz_id=102&utm_term=Bcrypt%E5%9C%A8go%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-139095268.142^v102^pc_search_result_base1&spm=1018.2226.3001.4187)

[Hash算法加密，BCrypt加密算法在java和go中的应用](https://blog.csdn.net/w_monster/article/details/127077024?ops_request_misc=%257B%2522request%255Fid%2522%253A%252208a7e4837c0a7824f3e4cbb94564fae7%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=08a7e4837c0a7824f3e4cbb94564fae7&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-20-127077024-null-null.142^v102^pc_search_result_base1&utm_term=%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95bcrypt&spm=1018.2226.3001.4187)

##### 1.3 代码对比

###### 1.31 自己

![image-20250308163446682](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308163446682.png)

![image-20250308163645045](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308163645045.png)

###### 1.32 博客

![image-20250308163552200](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308163552200.png)

![image-20250308163732105](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308163732105.png)

#### 2. JSON数据格式

##### 2.1 选择原因：轻便易用

参考资料：

[前后端交互数据格式：构建高效沟通的桥梁](https://blog.csdn.net/xycxycooo/article/details/141228858?ops_request_misc=%257B%2522request%255Fid%2522%253A%25223c2945138119e66238745dc244f130c8%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=3c2945138119e66238745dc244f130c8&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-141228858-null-null.142^v102^pc_search_result_base1&utm_term=%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92%E6%A0%BC%E5%BC%8F&spm=1018.2226.3001.4187)

##### 2.2 技术路线

因为我了解到，`c.JSON`是Gin框架中返回JSON响应的方法，

所以在gin中文文档、CSDN、博客园上搜相关代码仿照学习

参考资料：

[gin文档-JSON数据的解析和绑定](https://www.topgoer.com/gin%E6%A1%86%E6%9E%B6/gin%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%92%8C%E7%BB%91%E5%AE%9A/json%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%92%8C%E7%BB%91%E5%AE%9A.html)

[深入浅出：Gin框架中的JSON响应与错误处理](https://blog.csdn.net/zhaoxilengfeng/article/details/144299129?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522f042cb84b3f6a9d36bfc63013e93d022%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=f042cb84b3f6a9d36bfc63013e93d022&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-144299129-null-null.142^v102^pc_search_result_base1&utm_term=c.JSON%20gin&spm=1018.2226.3001.4187)

[Gin 框架怎么验证绑定到结构体的字段？](https://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&mid=2247488047&idx=1&sn=2b98b870cd5289f63ce2cdf586007066&chksm=9f81b841a8f6315720f84830cdc78d9c801a6da92d58a7cd7510545345cdf9ca2a0a55423ac0&scene=21#wechat_redirect)

[Gin 框架 JSON 格式返回结果的使用方式](https://www.cnblogs.com/cheyunhua/p/18566752)

[Golang Gin框架获取JSON输入](https://blog.csdn.net/u010844836/article/details/145571484?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522ed55c664893fba825dc6b943c1fc872a%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=ed55c664893fba825dc6b943c1fc872a&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-3-145571484-null-null.142^v102^pc_search_result_base1&utm_term=Golang%20gin%E6%A1%86%E6%9E%B6%20c.JSON&spm=1018.2226.3001.4187)

##### 2.3 代码对比

###### 2.31 自己

![image-20250308171912243](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308171912243.png)

![image-20250308172038817](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308172038817.png)

###### 2.32 博客

![image-20250308171744138](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308171744138.png)

![image-20250308171947498](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308171947498.png)

---

### 三. 项目结构

#### 1. 简略/详细 

##### 1.1 简略版

```go
/mms
├── main.go         # 入口文件
├── go.mod/go.sum   # Go 依赖管理
├── config          # 配置管理
│   ├── database.go # 数据库连接
├── models          # 数据库模型
│   ├── user.go     # 用户模型
├── controllers     # 业务逻辑
│   ├── user.go     # 用户相关逻辑
├── routes          # 路由管理
│   ├── routes.go   # API 路由
├── middleware      # 中间件
│   ├── auth.go     # 认证与权限管理
├── utils           # 工具函数
│   ├── password.go # 密码加密工具
```

##### 1.2 详细版

```go
/mms
├── main.go  		# 程序入口文件，初始化数据库连接、配置路由和启动Web服务
├── go.mod			# Go模块管理文件，记录项目依赖的Go模块及其版本，确保依赖版本的一致性
├── go.sum			# Go模块管理文件，记录依赖模块的哈希值，确保项目依赖模块的完整性
├── config			# 项目配置文件目录，存放数据库等配置信息
│   └── database.go # 数据库配置文件，配置数据库连接
├── models			# 数据库模型定义文件目录，定义与数据库表结构对应的Go结构体
│   └── user.go 	# 用户模型定义文件，定义与用户数据表对应的Go结构体
├── controllers		# 业务逻辑处理文件目录，处理具体的业务操作
│   └── user.go 	# 处理用户相关业务逻辑的文件，处理用户相关的业务逻辑，比如注册、登录等
├── routes 			# 路由配置文件目录，定义所有API接口的路由规则
│   └── routes.go 	# 路由配置文件，设置每个接口的路由规则及其对应的处理函数
├── middleware 		# 中间件文件目录，用于请求处理过程中的功能扩展
│   └── auth.go 	# 身份验证中间件文件，验证用户身份和管理员权限
└── utils 			# 工具函数目录，包含项目中常用的辅助功能
    └── password.go # 密码加密和验证的工具函数文件，加密存储密码并验证用户密码是否正确
```

#### 2. 设计思路

根据需求分析，推测需要哪些目录/文件，之后参考类似项目的结构进行优化

#### 3. 技术路线

##### step1.根据需求分析推测文件

* `main.go`程序入口文件(必需)

* `go.mod`和`go.sum`是GO依赖管理文件（必需）

* 由于项目需要使用 MySQL 作为数据库，因此需要一个专门的文件来处理数据库连接

* 由于项目使用 GORM 进行 ORM 操作，因此需要一个文件专门定义数据库模型

* 由于项目涉及用户注册、登录、信息更新等操作，因此需要一个专门的文件存放 `Register`、`Login`、`UpdateUser` 等核心业务逻辑函数

* 由于项目中使用一些路由，因此可用一个文件管理这些路由

* 由于项目使用 `Bcrypt`算法进行密码加密存储，因此需要一个工具文件专门负责加密逻辑

* 由于项目使用`JWT`进行身份验证，因此可用一个文件存放中间件进行身份验证



由此，可以初步确定项目的基本结构，

但是，文件的命名不一定符合规范，

这时，可参考网上类似的项目结构，

参考它的命名方式给这些文件命名。



##### step2.参考类似项目结构优化

比如：可以Google搜”Gin 框架项目结构'',也可以GitHub搜`gin admin`

![image-20250308183303656](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308183303656.png)

```
├── cmd                             (命令行定义目录)
│   ├── start.go                    (启动命令)
│   ├── stop.go                     (停止命令)
│   └── version.go                  (版本命令)
├── configs
│   ├── dev
│   │   ├── logging.toml            (日志配置文件)
│   │   ├── middleware.toml         (中间件配置文件)
│   │   └── server.toml             (服务配置文件)
│   ├── menu.json                   (初始化菜单文件)
│   └── rbac_model.conf             (Casbin RBAC 模型配置文件)
├── internal
│   ├── bootstrap                   (初始化目录)
│   │   ├── bootstrap.go            (初始化)
│   │   ├── http.go                 (HTTP 服务)
│   │   └── logger.go               (日志服务)
│   ├── config                      (配置文件目录)
│   │   ├── config.go               (配置文件初始化)
│   │   ├── consts.go               (常量定义)
│   │   ├── middleware.go           (中间件配置)
│   │   └── parse.go                (配置文件解析)
│   ├── mods
│   │   ├── rbac                    (RBAC 模块)
│   │   │   ├── api                 (API层)
│   │   │   ├── biz                 (业务逻辑层)
│   │   │   ├── dal                 (数据访问层)
│   │   │   ├── schema              (数据模型层)
│   │   │   ├── casbin.go           (Casbin 初始化)
│   │   │   ├── main.go             (RBAC 模块入口)
│   │   │   └── wire.go             (RBAC 依赖注入初始化)
│   │   └── mods.go
│   ├── utility
│   │   └── prom
│   │       └── prom.go             (Prometheus 监控，用于集成 prometheus)
│   └── wirex                       (依赖注入目录，包含了依赖组的定义和初始化)
│       ├── injector.go
│       ├── wire.go
│       └── wire_gen.go
├── pkg                             (公共包目录)
│   ├── cachex                      (缓存包)
│   ├── crypto                      (加密包)
│   │   ├── aes                     (AES加密)
│   │   ├── hash                    (哈希加密)
│   │   └── rand                    (随机数)
│   ├── encoding                    (编码包)
│   │   ├── json                    (JSON编码)
│   │   ├── toml                    (TOML编码)
│   │   └── yaml                    (YAML编码)
│   ├── errors                      (错误处理包)
│   ├── gormx                       (Gorm扩展包)
│   ├── jwtx                        (JWT包)
│   ├── logging                     (日志包)
│   ├── mail                        (邮件包)
│   ├── middleware                  (中间件包)
│   ├── oss                         (对象存储包)
│   ├── promx                       (Prometheus包)
│   └── util                        (工具包)
├── test                            (单元测试目录)
│   ├── menu_test.go
│   ├── role_test.go
│   ├── test.go
│   └── user_test.go
├── Dockerfile
├── Makefile
├── README.md
├── go.mod
├── go.sum
└── main.go                         (入口文件)
```



由此可知，

* 负责数据库的连接的文件可以命名为`database.go`,存放在`config`目录下

* 负责模型定义的文件可以命名为`user.go`,存放在`models`目录下

* 存放负责操作函数的文件可以命名为`user.go`,存放在`controller`目录下

* 存放这些路由的文件可以命名为`router.go`,存放在`router`目录下

* 负责密码的加密存储的文件可以命名为`password.go`,存放在`util`目录下

* 存放JWT身份验证中间件函数的文件可以命名为`auth.go`,存放在`middleware`目录下



#### 4. 参考资料

[一个经典的Gin Web项目结构](https://tehub.com/a/cnVATMhPAu)

[项目重构，从零开始搭建一套新的后台管理系统（后端版）](https://developer.aliyun.com/article/1392259)

[gin-admin](https://github.com/LyricTian/gin-admin)

[go-admin](https://github.com/hequan2017/go-admin)

[gin-skeleton](https://github.com/fanqingxuan/gin-skeleton)

---

### 四. 实现步骤

#### 1. 初始化项目

##### 1.1 创建项目

###### 1.11 打开 Linux 虚拟机

###### 1.12 VSCode 远程连接虚拟机

###### 1.13 VSCode 打开终端

法一：在文件浏览器中直接新建文件夹，右键“在集成终端中打开”

法二：`Ctrl + ~`

###### 1.14 创建项目目录、进入并初始化 Go 模块

```bash
mkdir ~/Go/gopath/mms     #在gopath路径下新建一个mms文件夹
cd ~/Go/gopath/mms		  #进入mms文件夹
go mod init mms			  #初始化Go模块，生成go.mod文件
```

##### 1.2 安装依赖

```bash
go get -u github.com/gin-gonic/gin		#安装Gin框架
go get -u gorm.io/gorm					#安装Gorm库
go get -u gorm.io/driver/mysql			#安装Mysql驱动
go get -u golang.org/x/crypto/bcrypt	#安装Bcrypt加密库
go get -u github.com/golang-jwt/jwt/v4 	#安装JWT库
```

#### 2. 配置数据库

##### 2.1 Linux 虚拟机打开终端

###### 2.11 启动MySQL服务

```bash
sudo systemctl start mysql
```

###### 2.12 检查MySQL服务状态

```bash
sudo systemctl status mysql
```

##### 2.2 宿主机打开 Workbench

###### 2.21 创建数据库

```sql
CREATE DATABASE mms;
```

##### 2.3 `config / database.go`配置数据库连接

###### 2.31 代码实现

```go
// 声明当前文件属于config包
package config

// 导入其他包或模块
import (
	"fmt" //fmt包
	"gorm.io/driver/mysql" //GROM的MySQL驱动包
	"gorm.io/gorm"  //GROM的核心包
	"mms/models" //项目的模型包
)

// 定义全局变量DB
var DB *gorm.DB

// 定义InitDB函数，初始化数据库连接
func InitDB() {
    dsn := "ZhouQuan:@ZhouQuan1134@tcp(192.168.220.129:3306)/mms?charset=utf8mb4&parseTime=True&loc=Local"
    
    //通过GORM连接MySQL数据库
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    
    //检查数据库连接是否成功
    if err != nil {
        panic("数据库连接失败: " + err.Error())
    }

    //将成功建立的数据库连接实例db赋值给全局变量DB
    DB = db
    fmt.Println("数据库连接成功")
    
    //自动迁移User模型
    db.AutoMigrate(&models.User{})
}
```

###### 2.32 技术路线

结合参考“博客文章”和“阶段七实践“代码进行仿写

###### 2.33 参考代码

###### a. 博客

![image-20250308203605529](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308203605529.png)

###### b. 阶段七实践

![image-20250308204025502](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308204025502.png)

###### 2.34 参考资料

[【Golang】——Gin 框架与数据库集成详解](https://blog.csdn.net/weixin_73901614/article/details/143908899)

##### 2.4 `main.go`初始化数据库

###### 2.41 代码实现

```go
// 声明当前文件属于main包
package main 

// 导入其他包或模块
import ( 
	"mms/config" //项目的配置包
	"mms/routes" //项目的路由包
)

// main()函数，Go程序的入口
func main() {
	
	//调用config包中的InitDB()函数
	//作用：初始化数据库连接：1.连接到MySQL数据库 2.自动迁移数据库表结构
	config.InitDB() 

	//调用routes包中的SetupRouter()函数，返回给一个r对象
	//作用：初始化路由配置，返回一个 *gin.Engine 实例
	r := routes.SetupRouter() 
	
	//启动Web服务器并监听8080端口，等待用户的HTTP请求
	r.Run(":8080")
}
```

![image-20250308210614829](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308210614829.png)

###### 2.42 技术路线

结合参考“博客文章”代码进行仿写

###### 2.43 参考代码

###### a. 博客

![image-20250308210800930](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308210800930.png)

###### b. 参考资料

[【Golang】——Gin 框架与数据库集成详解](https://blog.csdn.net/weixin_73901614/article/details/143908899)

#### 3. 定义用户模型

##### 3.1 `models/user.go`创建用户模型

###### 3.11 代码实现

```go
// 声明当前文件属于models包
package models

// 定义User结构体
type User struct {
	ID         uint  `gorm:"primaryKey"` 
	UserID    string `gorm:"unique;not null"` 
	Password  string `gorm:"not null"` 
	Nickname  string 
	Phone     string 
	Email     string `gorm:"unique"` 
	IsAdmin   bool   `gorm:"default:false"` 
	IsApproved bool  `gorm:"default:false"`	
} 
```

###### 3.12 技术路线

结合参考“博客文章”代码进行仿写

###### 3.13 参考代码

​	![image-20250308213341225](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308213341225.png)

###### 3.14 参考资料

[【Golang】——Gin 框架与数据库集成详解](https://blog.csdn.net/weixin_73901614/article/details/143908899)

##### 3.2 `config / database.go`设置模型自动迁移

###### 3.21 代码实现

```go
// 声明当前文件属于config包
package config

// 导入其他包或模块
import (
	"fmt" //fmt包
	"gorm.io/driver/mysql" //GROM的MySQL驱动包
	"gorm.io/gorm"  //GROM的核心包
	"mms/models" //项目的模型包
)

// 定义全局变量DB
var DB *gorm.DB

// 定义InitDB函数，初始化数据库连接
func InitDB() {
    dsn := "ZhouQuan:@ZhouQuan1134@tcp(192.168.220.129:3306)/mms?charset=utf8mb4&parseTime=True&loc=Local"
    
    //通过GORM连接MySQL数据库
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    
    //检查数据库连接是否成功
    if err != nil {
        panic("数据库连接失败: " + err.Error())
    }

    //将成功建立的数据库连接实例db赋值给全局变量DB
    DB = db
    fmt.Println("数据库连接成功")
    
    //自动迁移User模型
    db.AutoMigrate(&models.User{})
}
```

![image-20250308213705975](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308213705975.png)

###### 3.22 技术路线

结合参考“博客文章”和”阶段七实践“代码进行仿写

###### 3.23 参考代码

###### a. 博客

​	![image-20250308213924426](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308213924426.png)

###### b. 阶段七实践

![image-20250308214111097](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308214111097.png)

###### 3.24 参考资料

[【Golang】——Gin 框架与数据库集成详解](https://blog.csdn.net/weixin_73901614/article/details/143908899)

#### 4. 处理业务逻辑

```go
// 声明当前文件属于controllers包
package controllers

// 导入其他包或模块
import (
	"github.com/gin-gonic/gin"	//Gin框架
	"github.com/golang-jwt/jwt/v4" //JWT库
	"mms/config" //项目的配置包
	"mms/models" //项目的模型包
	"mms/utils" //项目的工具包
	"net/http" //HTTP包
	"time" //时间包
)

// 用户注册

// RegisterRequest结构体定义用户注册时的请求结构
type RegisterRequest struct {
	UserID   string `json:"user_id" binding:"required"` 
	Password string `json:"password" binding:"required"` 
	Nickname string `json:"nickname"` 
	Phone    string `json:"phone"` 
	Email    string `json:"email"` 
}

// Register函数处理用户注册请求
func Register(c *gin.Context) {
	
	// 声明变量req，类型是RegisterRequest，存储客户端传递的用户注册请求的数据
	var req RegisterRequest
	
	// 绑定请求数据
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return 
	}

	// 使用bcrypt算法加密密码
	hashedPassword, err := utils.HashPassword(req.Password)
	//检查err是否为nil，如果err不为nil，表示加密过程中发生了错误
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "密码加密失败"})
		return 
	}

	// 创建用户对象
	//创建一个User模型实例(用户对象)user，用来存储用户信息
	user := models.User{
		UserID:    req.UserID,
		Password:  hashedPassword,
		Nickname:  req.Nickname, 
		Phone:     req.Phone, 
		Email:     req.Email, 
		IsApproved: false, 
		IsAdmin:    false, 
	}

	// 将用户对象保存到数据库
	if result := config.DB.Create(&user); result.Error != nil {
		c.JSON(http.StatusConflict, gin.H{"error": "用户已存在"})
		return 
	}
	c.JSON(http.StatusCreated, gin.H{"message": "注册成功，等待管理员审核"})
}

// 用户登录
// LoginRequest结构体定义用户登录时的请求结构
type LoginRequest struct {
	UserID   string `json:"user_id" binding:"required"` //用户名，必填
	Password string `json:"password" binding:"required"` //密码，必填
}

// Login函数处理用户登录请求
func Login(c *gin.Context) {

	// 声明变量req，类型是LoginRequest，存储客户端传递的用户登录请求的数据
	var req LoginRequest
	
	// 绑定请求数据
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return 
	}

	// 创建用户对象
	var user models.User

	// 查询数据库，检查请求登录的用户是否存在
	if result := config.DB.Where("user_id = ?", req.UserID).First(&user); result.Error != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "用户不存在"})
		return 
	}

	// 检查请求登录的用户是否已通过审核
	if !user.IsApproved {
		c.JSON(http.StatusForbidden, gin.H{"error": "账户未通过审核"})
		return 
	}

	// 验证用户输入的密码是否正确
	if !utils.CheckPassword(req.Password, user.Password) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "密码错误"})
		return
	}

	// 生成JWT token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": user.UserID,
		"admin":   user.IsAdmin, 
		"exp":     time.Now().Add(time.Hour * 72).Unix(),
	})
	tokenString, _ := token.SignedString([]byte("your-secret-key")) 
	c.JSON(http.StatusOK, gin.H{"token": tokenString})
}


// UpdateUser函数处理更新用户信息的请求
func UpdateUser(c *gin.Context) {
    currentUser, exists := c.Get("user")
	if !exists {
		
        c.JSON(http.StatusUnauthorized, gin.H{"error": "用户未认证"})
        return //结束当前函数的执行，返回调用者
    }

    user := currentUser.(models.User)
    var updateData struct {
        Nickname *string `json:"nickname"` 
        Phone    *string `json:"phone"`	
        Email    *string `json:"email"` 
    }
	
    if err := c.ShouldBindJSON(&updateData); err != nil {
        
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return 
    }

    // 部分更新逻辑
    if updateData.Nickname != nil {
        user.Nickname = *updateData.Nickname
    }
	//检查请求中是否提供了Phone字段，如果提供了，更新user.Phone
    if updateData.Phone != nil {
        user.Phone = *updateData.Phone
    }
	//检查请求中是否提供了Email字段，如果提供了，更新user.Email
    if updateData.Email != nil {
	
        user.Email = *updateData.Email
    }

    // 保存到数据库
    if result := config.DB.Save(&user); result.Error != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "更新失败"})
        return 
    }
    c.JSON(http.StatusOK, gin.H{"message": "用户信息更新成功", "user": user})
}

// DeleteUser函数处理删除用户请求
func DeleteUser(c *gin.Context) {
	userID := c.Param("id") 

	// 强制删除用户记录（物理删除）
	if result := config.DB.Unscoped().Where("user_id = ?", userID).Delete(&models.User{}); result.Error != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "用户未找到"})
		return //结束当前函数的执行，返回调用者
	}
	c.JSON(http.StatusOK, gin.H{"message": "用户删除成功"})
}


// GetUser函数处理获取单个用户信息请求
func GetUser(c *gin.Context) {
	userID := c.Param("id")
	var user models.User
	if result := config.DB.Where("user_id = ?", userID).First(&user); result.Error != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "用户未找到"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"user": user})
}

// GetAllUsers函数处理获取所有用户信息请求
func GetAllUsers(c *gin.Context) {
	var users []models.User
	if result := config.DB.Find(&users); result.Error != nil {
		
		c.JSON(http.StatusInternalServerError, gin.H{"error": "获取用户失败"})
		return //结束当前函数的执行，返回调用者
	}


	c.JSON(http.StatusOK, gin.H{"users": users})
}

// ApproveUser函数处理审核用户请求

func ApproveUser(c *gin.Context) {
	userID := c.Param("id") 

	// 创建用户对象
	var user models.User

	
	// 查询数据库，检查请求获取的用户是否存在
	if result := config.DB.Where("user_id = ?", userID).First(&user); result.Error != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "用户未找到"})
		return 
	}

	// 修改用户审核状态为通过
	user.IsApproved = true
	if result := config.DB.Save(&user); result.Error != nil {

		c.JSON(http.StatusInternalServerError, gin.H{"error": "审核失败"})
		return 
	}

	c.JSON(http.StatusOK, gin.H{"message": "用户审核通过", "user": user})
}
```

`controllers/user.go`设置一系列函数处理业务操作

##### 4.1 用户注册

###### 4.11代码实现

```go
// 用户注册

// RegisterRequest结构体定义用户注册时的请求结构
type RegisterRequest struct {
	UserID   string `json:"user_id" binding:"required"` 
	Password string `json:"password" binding:"required"` 
	Nickname string `json:"nickname"` 
	Phone    string `json:"phone"` 
	Email    string `json:"email"` 
}

// Register函数处理用户注册请求
func Register(c *gin.Context) {
	
	// 声明变量req，类型是RegisterRequest，存储客户端传递的用户注册请求的数据
	var req RegisterRequest
	
	// 绑定请求数据
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return 
	}

	// 使用bcrypt算法加密密码
	hashedPassword, err := utils.HashPassword(req.Password)
	//检查err是否为nil，如果err不为nil，表示加密过程中发生了错误
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "密码加密失败"})
		return 
	}

	// 创建用户对象
	//创建一个User模型实例(用户对象)user，用来存储用户信息
	user := models.User{
		UserID:    req.UserID,
		Password:  hashedPassword,
		Nickname:  req.Nickname, 
		Phone:     req.Phone, 
		Email:     req.Email, 
		IsApproved: false, 
		IsAdmin:    false, 
	}

	// 将用户对象保存到数据库
	if result := config.DB.Create(&user); result.Error != nil {
		c.JSON(http.StatusConflict, gin.H{"error": "用户已存在"})
		return 
	}
	c.JSON(http.StatusCreated, gin.H{"message": "注册成功，等待管理员审核"})
}
```

###### 4.12 技术路线

在GitHub参照类似项目，在CSDN参照类似文章，仿写代码

###### 4.13 参考代码

###### a. GitHub

![image-20250308220227621](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308220227621.png)

###### b. CSDN

![image-20250308220321966](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308220321966.png)

###### 4.14 参考资料

[Go-Web-using-Gorm-Gin-MySQL](https://github.com/spike10511/Go-Web-using-Gorm-Gin-MySQL)

[Golang——Gin 框架与数据库集成详解](https://blog.csdn.net/weixin_73901614/article/details/143908899)

##### 4.2 用户登录

###### 4.21 代码实现

```go
// 用户登录
// LoginRequest结构体定义用户登录时的请求结构
type LoginRequest struct {
	UserID   string `json:"user_id" binding:"required"` //用户名，必填
	Password string `json:"password" binding:"required"` //密码，必填
}

// Login函数处理用户登录请求
func Login(c *gin.Context) {

	// 声明变量req，类型是LoginRequest，存储客户端传递的用户登录请求的数据
	var req LoginRequest
	
	// 绑定请求数据
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return 
	}

	// 创建用户对象
	var user models.User

	// 查询数据库，检查请求登录的用户是否存在
	if result := config.DB.Where("user_id = ?", req.UserID).First(&user); result.Error != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "用户不存在"})
		return 
	}

	// 检查请求登录的用户是否已通过审核
	if !user.IsApproved {
		c.JSON(http.StatusForbidden, gin.H{"error": "账户未通过审核"})
		return 
	}

	// 验证用户输入的密码是否正确
	if !utils.CheckPassword(req.Password, user.Password) {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "密码错误"})
		return
	}

	// 生成JWT token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id": user.UserID,
		"admin":   user.IsAdmin, 
		"exp":     time.Now().Add(time.Hour * 72).Unix(),
	})
	tokenString, _ := token.SignedString([]byte("your-secret-key")) 
	c.JSON(http.StatusOK, gin.H{"token": tokenString})
}
```

###### 4.22 技术路线

在GitHub参照类似项目，仿写代码

###### 4.23 参考代码

![image-20250308221956811](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308221956811.png)

###### 4.24 参考资料

[Go-Web-using-Gorm-Gin-MySQL](https://github.com/spike10511/Go-Web-using-Gorm-Gin-MySQL)

##### 4.3 更新用户

###### 4.31 代码实现

```go
// UpdateUser函数处理更新用户信息的请求
func UpdateUser(c *gin.Context) {
    currentUser, exists := c.Get("user")
	if !exists {
		
        c.JSON(http.StatusUnauthorized, gin.H{"error": "用户未认证"})
        return //结束当前函数的执行，返回调用者
    }

    user := currentUser.(models.User)
    var updateData struct {
        Nickname *string `json:"nickname"` 
        Phone    *string `json:"phone"`	
        Email    *string `json:"email"` 
    }
	
    if err := c.ShouldBindJSON(&updateData); err != nil {
        
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
        return 
    }

    // 部分更新逻辑
    if updateData.Nickname != nil {
        user.Nickname = *updateData.Nickname
    }
	//检查请求中是否提供了Phone字段，如果提供了，更新user.Phone
    if updateData.Phone != nil {
        user.Phone = *updateData.Phone
    }
	//检查请求中是否提供了Email字段，如果提供了，更新user.Email
    if updateData.Email != nil {
	
        user.Email = *updateData.Email
    }

    // 保存到数据库
    if result := config.DB.Save(&user); result.Error != nil {
        c.JSON(http.StatusInternalServerError, gin.H{"error": "更新失败"})
        return 
    }
    c.JSON(http.StatusOK, gin.H{"message": "用户信息更新成功", "user": user})
}
```

###### 4.32 技术路线

在GitHub参照类似项目，在CSDN参照类似文章，参考“用户注册”仿写代码

###### 4.33 参考代码

###### a. GitHub

![image-20250308222407347](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308222407347.png)

###### b. CSDN

![image-20250308222437810](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308222437810.png)

![image-20250310072446455](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310072446455.png)

![image-20250310072607753](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310072607753.png)



###### 4.34 参考资料

[Go-Web-using-Gorm-Gin-MySQL](https://github.com/spike10511/Go-Web-using-Gorm-Gin-MySQL)

[Golang——Gin 框架与数据库集成详解](https://blog.csdn.net/weixin_73901614/article/details/143908899)

[Gin + Gorm 实现增删改查](https://blog.csdn.net/clearloe/article/details/139766244)

##### 4.4 删除用户

###### 4.41 代码实现

```go
// DeleteUser函数处理删除用户请求
func DeleteUser(c *gin.Context) {
	userID := c.Param("id") 

	// 强制删除用户记录（物理删除）
	if result := config.DB.Unscoped().Where("user_id = ?", userID).Delete(&models.User{}); result.Error != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "用户未找到"})
		return //结束当前函数的执行，返回调用者
	}
	c.JSON(http.StatusOK, gin.H{"message": "用户删除成功"})
}
```

###### 4.42 技术路线

在CSDN参照类似文章，在gorm中文文档查阅相关操作，仿写代码

###### 4.43 参考代码

![image-20250308222836964](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308222836964.png)

![image-20250310073948238](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310073948238.png)

![image-20250310074816182](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310074816182.png)

![image-20250310074926903](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310074926903.png)

###### 4.44 参考资料

[Golang——Gin 框架与数据库集成详解](https://blog.csdn.net/weixin_73901614/article/details/143908899)

[Gin + Gorm 实现增删改查](https://blog.csdn.net/clearloe/article/details/139766244)

[gorm中文文档-gorm删除](https://www.topgoer.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/gorm%E5%88%A0%E9%99%A4.html)

##### 4.5 查看单个用户

###### 4.51 代码实现

```go
// GetUser函数处理获取单个用户信息请求
func GetUser(c *gin.Context) {
	userID := c.Param("id")
	var user models.User
	if result := config.DB.Where("user_id = ?", userID).First(&user); result.Error != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "用户未找到"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"user": user})
}
```

###### 4.52 技术路线

在GitHub参照类似项目，在gorm中文文档查阅相关操作，仿写代码

###### 4.53 参考代码

![image-20250308223237526](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308223237526.png)

![image-20250310074510035](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310074510035.png)

###### 4.54 参考资料

[Go-Web-using-Gorm-Gin-MySQL](https://github.com/spike10511/Go-Web-using-Gorm-Gin-MySQL)

[gorm中文文档-gorm查询](https://www.topgoer.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/gorm%E6%9F%A5%E8%AF%A2.html)

##### 4.6 查看所有用户

###### 4.61 代码实现

```go
// GetAllUsers函数处理获取所有用户信息请求
func GetAllUsers(c *gin.Context) {
	var users []models.User
	if result := config.DB.Find(&users); result.Error != nil {
		
		c.JSON(http.StatusInternalServerError, gin.H{"error": "获取用户失败"})
		return //结束当前函数的执行，返回调用者
	}
	c.JSON(http.StatusOK, gin.H{"users": users})
}
```

###### 4.62 技术路线

在CSDN参照类似文章，仿写代码

###### 4.63 参考代码

![image-20250308223619263](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308223619263.png)

###### 4.64 参考资料

[Golang——Gin 框架与数据库集成详解](https://blog.csdn.net/weixin_73901614/article/details/143908899)

##### 4.7 审核用户

###### 4.71 代码实现

```go
// ApproveUser函数处理审核用户请求

func ApproveUser(c *gin.Context) {
	userID := c.Param("id") 

	// 创建用户对象
	var user models.User

	
	// 查询数据库，检查请求获取的用户是否存在
	if result := config.DB.Where("user_id = ?", userID).First(&user); result.Error != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "用户未找到"})
		return 
	}

	// 修改用户审核状态为通过
	user.IsApproved = true
	if result := config.DB.Save(&user); result.Error != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "审核失败"})
		return 
	}

	c.JSON(http.StatusOK, gin.H{"message": "用户审核通过", "user": user})
}
```

###### 4.72 技术路线

该函数的前半部分与“查看单个用户”的逻辑相同，后半部分与“更新用户”逻辑相同，先查询数据库以确定用户是否存在。查询成功后，将该用户的 `IsApproved` 字段更新为 `true` ，然后保存到数据库中即可

###### 4.73 参考代码

![image-20250310075952914](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310075952914.png)

![image-20250310080009106](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310080009106.png)

###### 4.74 参考资料

"查看单个用户"和“更新用户”代码

##### 5. 配置相关路由

在 `routes/routes.go`配置路由，在`main.go`文件初始化路由

###### 5.1 代码实现

```go
// 声明当前文件属于routes包
package routes

// 导入其他包或模块
import (
	"mms/controllers" //项目的控制器包，处理与业务逻辑相关的操作
	"mms/middleware" //项目的中间件包，设置中间件
	"github.com/gin-gonic/gin" //Gin框架，构建HTTP Web服务
)

// 设置项目的路由
func SetupRouter() *gin.Engine {
    //gin.Default()：创建一个默认的Gin路由引擎实例,并赋值给r，用于定义和管理路由
    r := gin.Default()

    // 公共接口

    //功能：注册接口 实现形式：POST请求的路由
    r.POST("/register", controllers.Register)

    //功能：登录接口 实现形式：POST请求的路由
    r.POST("/login", controllers.Login)

    // 需要认证的接口
    //创建一个路由组，用于定义需要认证的接口
    auth := r.Group("/")
    
    //auth.Use为路由组添加中间件
    auth.Use(middleware.AuthMiddleware())
    {
        //定义一个PUT请求的路由
        auth.PUT("/user/profile", controllers.UpdateUser) // 用户只能更新自己的信息
    }

    // 管理员接口
    //创建一个子路由组，用于定义管理员接口
    admin := auth.Group("/admin")

    //auth.Use为路由组添加中间件
    admin.Use(middleware.AdminMiddleware())
    {
        //定义一个DELETE请求的路由
        admin.DELETE("/users/:id", controllers.DeleteUser)
        
        //定义一个GET请求的路由
        admin.GET("/users/:id", controllers.GetUser)

        //定义一个GET请求的路由
        admin.GET("/users", controllers.GetAllUsers)

        //定义一个PUT请求的路由
        admin.PUT("/users/:id/approve", controllers.ApproveUser)
    }

    //返回配置好的Gin路由引擎实例r
    return r
}
```

```go
 // 声明当前文件属于main包
 package main 
 
 // 导入其他包或模块
 import ( 
 	"mms/config" //项目的配置包
 	"mms/routes" //项目的路由包
 )
 
 // main()函数，Go程序的入口
 func main() {
 	
 	//调用config包中的InitDB()函数
 	//作用：初始化数据库连接：1.连接到MySQL数据库 2.自动迁移数据库表结构
 	config.InitDB() 
 
 	//调用routes包中的SetupRouter()函数，返回给一个r对象
 	//作用：初始化路由配置，返回一个 *gin.Engine 实例
 	r := routes.SetupRouter() 
 	
 	//启动Web服务器并监听8080端口，等待用户的HTTP请求
 	r.Run(":8080")
 }
```

###### 5.2 代码思路

通过路由分组可将具有相同访问权限的路由组织在一起，

并为需要认证和管理员权限的分组分别添加相应的中间件来进行身份验证，

这样可以确保：

公共接口（注册和登录）任何人都能访问，

需要认证的接口只有已登录的用户才能访问，

管理员接口只有具有管理员权限的用户才能访问

###### 5.3 技术路线

根据项目功能需求，明确自己所需的路由，

在具体设置路由时，在GitHub参照类似项目，在CSDN参照类似文章，

结合路由分组和中间件的知识，仿写代码

###### 5.4 参考代码

###### a. GitHub

![image-20250308231327073](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308231327073.png)

###### b. CSDN

![image-20250308231340830](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308231340830.png)

###### c. Gin Web Framework

![image-20250310084734599](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310084734599.png)

![image-20250310082234868](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310082234868.png)

###### 5.5 参考资料

[Go-Web-using-Gorm-Gin-MySQL](https://github.com/spike10511/Go-Web-using-Gorm-Gin-MySQL)

[Golang——Gin 框架与数据库集成详解](https://blog.csdn.net/weixin_73901614/article/details/143908899)

[golang gin 后端开发框架（三）：路由组和中间件](https://www.cnblogs.com/aganippe/p/16077300.html)

[Gin Web Framework-路由组]()

[Gin Web Framework-使用中间件](https://gin-gonic.com/zh-cn/docs/examples/using-middleware/)

##### 6. 处理中间件

###### 6.1 代码实现

```go
// 声明当前文件属于middleware包
package middleware

// 导入其他包或模块
import (
	"github.com/gin-gonic/gin" //Gin框架，构建HTTP Web服务
	"github.com/golang-jwt/jwt/v4" //JWT库，生成和验证JSON Web Token
	"mms/config" //项目的配置包，配置数据库连接
	"mms/models" //项目的模型包，定义数据库模型
	"net/http" //HTTP包，处理HTTP请求和响应
	"strings" //字符串操作包
	
)
// 定义一个中间件函数，用于处理用户认证
func AuthMiddleware() gin.HandlerFunc {
    
    // 返回一个匿名函数，该函数接收一个参数c，类型是*gin.Context(是一个指向gin.Context的指针或是一个*gin.Context实例)，用于处理请求和生成响应
    return func(c *gin.Context) {
        tokenString := c.GetHeader("Authorization")
        if tokenString == "" {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "未提供认证令牌"})
            return 
        }

        // 去掉 "Bearer " 前缀
        tokenString = strings.TrimPrefix(tokenString, "Bearer ")

        // 解析令牌并验证有效性
        //jwt.Parse方法解析令牌字符串并验证其令牌签名的有效性，如果签名有效，token对象将包含解析后的令牌信息，如果签名无效，err将包含错误信息
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
            return []byte("your-secret-key"), nil 
        })
        
        if err != nil || !token.Valid {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "无效令牌"})
        
            return 
        }

        // 提取声明并验证user_id类型
        claims, ok := token.Claims.(jwt.MapClaims)
        if !ok {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "令牌声明格式错误"})
            return //结束当前函数的执行，返回调用者
        }

        //claims["user_id"]：从声明中获取user_id字段
        userID, ok := claims["user_id"].(string)
        if !ok || userID == "" {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "令牌中缺少用户ID"})
            return 
        }

        // 查询用户信息
        // 创建用户对象
	    //创建一个User模型实例(用户对象)user，用来存储用户信息(声明一个User类型的变量user，它是一个结构体实例，可以存储用户信息)
        var user models.User
        
        // 查询数据库，检查请求获取的用户是否存在
        if result := config.DB.Where("user_id = ?", userID).First(&user); result.Error != nil {
            c.AbortWithStatusJSON(http.StatusNotFound, gin.H{"error": "用户不存在"})
            return 
        }

        // 存储用户对象到上下文
        c.Set("user", user)
        c.Next()
    }
}

// 定义一个中间件函数，用于处理管理员认证
func AdminMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        
        // 从上下文中获取用户信息
        user, exists := c.Get("user")
        
        //如果exists为false，表示键"user"不存在，那么!exists为true，执行后续的代码
        if !exists {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "用户未认证"})
            return 
        }

        // 类型断言并检查管理员权限
        if !user.(models.User).IsAdmin {
            c.AbortWithStatusJSON(http.StatusForbidden, gin.H{"error": "需要管理员权限"})
            return 
        }

        //c：Gin框架的上下文对象，用于处理请求和生成响应
        c.Next()
    }
}
```

###### 6.2 技术路线

Google搜索``gin jwt 中间件``找类似文章，仿写代码

###### 6.3 参考代码

![image-20250308234311936](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308234311936.png)

![image-20250310090718438](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250310090718438.png)

###### 6.4 参考资料

[实现Gin框架JWT鉴权的中间件](https://juejin.cn/post/7211357900294914085)

[Golang gin 中间件类型](https://www.cnblogs.com/sening/p/17271644.html)

##### 7. 密码加密存储

`utils/password.go`使用`HashPassword函数借助bcrypt算法`加密，

使用`CheckPassword函数`验证密码是否匹配，

`controllers/user.go`调用这两个函数。

###### 7.1 代码实现

```go
// 使用bcrypt算法加密密码
hashedPassword, err := utils.HashPassword(req.Password)
//检查err是否为nil，如果err不为nil，表示加密过程中发生了错误
if err != nil {
	c.JSON(http.StatusInternalServerError, gin.H{"error": "密码加密失败"})
	return 
}
```

```go
// 声明当前文件属于utils包
package utils

// 导入其他包或模块
import "golang.org/x/crypto/bcrypt" //bcrypt 包，用于密码加密和验证

// HashPassword函数使用bcrypt算法加密密码
func HashPassword(password string) (string, error) {
	bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	return string(bytes), err
}

// CheckPassword函数验证密码是否匹配
func CheckPassword(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
	return err == nil
}
```

###### 7.2 技术路线

在CSDN上搜` Bcrypt在go中的使用` ,阅读相关博客，学习相关代码

###### 7.3 参考代码

![image-20250308163552200](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308163552200.png)

![image-20250308163732105](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250308163732105.png)

###### 7.4 参考资料

[Go 使用bcrypt实现密码加密和和校验](https://blog.csdn.net/qq_39335595/article/details/139095268?ops_request_misc=&request_id=&biz_id=102&utm_term=Bcrypt%E5%9C%A8go%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-139095268.142^v102^pc_search_result_base1&spm=1018.2226.3001.4187)

[Hash算法加密，BCrypt加密算法在java和go中的应用](https://blog.csdn.net/w_monster/article/details/127077024?ops_request_misc=%257B%2522request%255Fid%2522%253A%252208a7e4837c0a7824f3e4cbb94564fae7%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=08a7e4837c0a7824f3e4cbb94564fae7&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-20-127077024-null-null.142^v102^pc_search_result_base1&utm_term=%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95bcrypt&spm=1018.2226.3001.4187)