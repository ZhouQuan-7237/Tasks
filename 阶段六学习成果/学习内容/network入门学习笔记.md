# network入门学习笔记——周全

## 学习目录

一.network的前世今生

二.网络模型初识

1. 三种模型
2. OSI模型

三.TCP/IP初识

1. TCP/IP参考模型

2. 主要特点

3. 报文结构

4. 握手挥手

   三次握手（建立连接）

   四次挥手（释放连接）

   TIME-WAIT状态原因

   通俗理解

四.HTTP初识

1. 报文结构
2. 请求/响应

## 学习内容

### 一.network的前世今生

![image-20250207130146043](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250207130146043.png)

* 1969年：ARPANET诞生

  美国高级研究计划署（ARPA）推出了ARPANET，使用分组交换技术解决了数据包寻址问题，标志着现代互联网的起点。

* 1981年：TCP/IP协议规范化

  TCP/IP协议的标准化使不同的计算机网络能够实现互联，为互联网的全球发展奠定了基础。

* 1983年：TCP/IP协议成为标准

  ARPANET、PRNET和SATNET三个原始网络开始统一采用TCP/IP协议，确保了跨平台的兼容性。

* 1984年：DNS技术实现

  DNS（域名系统）首次实现，简化了互联网地址的解析过程，使得用户能够通过易记的域名访问网站。

* 1986年：现代邮件路由系统

  MERS（邮件交换路由系统）正式完成，电子邮件成为常见的通信工具。

* 1989年：PSINet成立

  全球首个商用网络运营商PSINet成立，标志着互联网的商业化起步。

* 1990年：首个网络搜索引擎

  网络搜索引擎Archie发布，方便了用户在互联网上的信息检索。

* 1991年：WWW正式发布

  万维网（WWW）由蒂姆·伯纳斯-李推出，标志着互联网信息共享的正式启航。

* 1995年：电子商务兴起

  亚马逊和eBay等电子商务平台的成立，推动了互联网商业化的进程。

* 2000年：互联网泡沫破裂

  互联网泡沫的破裂是市场过热后的调整，尽管短期内带来负面影响，但也促使互联网逐步成熟。

* 2004年：Facebook成立

  社交网络的代表——Facebook正式成立，推动了社交媒体在全球的普及。

* 2014年：HTTPS普及

  谷歌浏览器开始全面支持HTTPS协议，推动了网络安全技术的普及。

### 二.网络模型初识

#### 1. **三种模型**

* **OSI 参考模型**：理论框架，描述通信过程的各个阶段。

* **TCP/IP 参考模型**：实际应用，是互联网的基础通信模型。

* **原理参考模型**：折中方案，常用于教学，简化理解。

![408.oss-cn-hangzhou.aliyuncs.com体系结构 - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/408.oss-cn-hangzhou.aliyuncs.com体系结构 - 副本.png)

![7b98f2d89aa47ad6a888439461806a55 - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/7b98f2d89aa47ad6a888439461806a55 - 副本.png)

#### 2. OSI参考模型 

![img](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/829fdfc122e8e9efc3bc7b63a5cd6968.gif)

* **物理层**
  * 作用：通过物理介质传输原始比特流，实现设备间的物理连接。
  * 比喻：就像是快递公司送货的“运输工具”（卡车、火车、飞机），物理层提供数据传输的“运输工具”。
  *  举例：网线（连接计算机的电缆）、光纤（高速数据传输线）、无线电波（Wi-Fi信号）等。

* **数据链路层**

  * 作用：通过差错控制、流量控制和介质访问控制等机制，确保物理层传输的数据准确、完整地送到给目标设备。
  * 比喻：就像快递员在搬运过程中确保包裹不会丢失或破损，数据链路层确保数据准确、完整地通过这些道路送到目标。

  *  举例：以太网（计算机局域网的常见协议）、Wi-Fi（无线网络）、交换机（在局域网内根据MAC地址转发数据包）等。

* **网络层**
  * 作用：通过路由选择和地址寻址等机制，确保数据包从源主机到目标主机的正确传输。
  * 比喻：就像快递公司负责根据地址选择最合适的运输路线，确保包裹按时送达，网络层负责决定数据传输应该选哪条道路。
  *  举例：路由器（负责在不同网络间转发数据包）、IP（网络地址的分配和路由）、ICMP（错误报告和诊断工具）等。

* **传输层**
  * 作用：通过流量控制和差错检测等机制，为应用程序提供端到端的可靠传输服务。
  * 比喻：就像快递公司确保包裹在运输过程中不丢失，并且送达的时间是可控的，传输层确保数据顺利无误地送到目标。
  *  举例：TCP（保证可靠传输的协议）、UDP（不保证可靠性的协议，适用于实时应用）等。

* **会话层**
  * 作用：管理应用程序之间的通信会话，确保数据交换的有序和可靠。
  * 比喻：就像一个会议的主持人，确保参会人员之间的交流是有序和高效的，会话层负责管理不同应用程序之间的“对话”，确保两个应用程序之间的交流是有序的，能够建立连接、维持连接，并在交流结束后断开连接。
  * 举例：SSL/TLS（用于加密通信的协议，确保对话的安全）、NetBIOS（用于网络通信的协议）等。

* **表示层**
  * 作用：处理数据格式转换、加密解密等，确保数据在不同系统间的互操作性。
  * 比喻：就像翻译员，帮助不同语言的人进行沟通，表示层确保不同系统之间可以理解数据。
  * 举例：ASCII（字符编码，用于表示文本）、JPEG（图片格式）、MPEG（视频格式）、SSL/TLS（加密协议）等。

* **应用层**

  * 作用：为用户和应用程序提供服务，通过协议实现数据传输、编解码与格式化，确保用户请求得到响应。
  * 比喻：就像快递公司的客服，处理用户具体的服务请求，确保客户的需求得到响应，应用层是与用户直接互动的层次，通过协议提供不同的网络服务。

  *  举例：HTTP（用于网页浏览）、FTP（文件传输）、SMTP（电子邮件发送）、DNS（域名解析）、SSH（安全外壳协议）等。

### 三.TCP/IP初识

#### 1. TCP/IP参考模型

![img](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/1428261-20230613111522523-1912914160.png)

![a4e3ddb8b128ee1d95879b89a00bd53a - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/a4e3ddb8b128ee1d95879b89a00bd53a - 副本.png)

* **应用层**
  * 作用：为应用层、表示层和会话层的组合，用户和应用程序提供服务。它直接与用户交互，并处理不同应用程序之间的通信需求。
  * 举例：HTTP（用于网页浏览）、FTP（文件传输）、SMTP（电子邮件发送）、DNS（域名解析）、SSH（安全外壳协议）等。
* **传输层**
  * 作用：通过流量控制和差错检测等机制，为应用程序提供端到端的可靠传输服务。
  * 举例：TCP（传输控制协议）、UDP（用户数据报协议）等。
* **网络层**
  * 作用：通过路由选择和地址寻址等机制，确保数据包从源主机到目标主机的正确传输。
  * 举例：路由器（负责在不同网络间转发数据包）、IP（网络地址的分配和路由）、ICMP（错误报告和诊断工具）等。
* **网络接口层**
  * 作用：为数据链路层和物理层的组合，负责数据帧的传输和网络设备之间的物理连接。
  * 举例：ARP（地址解析协议）、RARP（反向地址解析协议）、以太网（计算机局域网的常见协议）、Wi-Fi（无线网络）等。

#### 2.主要特点

- **面向连接**：传输前通过三次握手建立连接，确保可靠通信。
- **点对点通信**：仅支持两端点间的通信，不支持多播或广播。
- **字节流传输**：数据以字节流形式传输，不保留报文边界。
- **可靠传输**：通过确认重传、序列号、校验和等机制，确保数据准确、有序传输。
- **端到端可靠性**：提供端到端的可靠传输，确保数据准确到达接收方。
- **拥塞控制**：采用慢启动、拥塞避免等算法，动态调整传输速率，避免网络拥塞。
- **全双工通信**: 支持双向数据传输，双方可同时发送和接收数据。

#### 3.报文结构

![ab4257062a72ce296f772115ed9d4784 - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/ab4257062a72ce296f772115ed9d4784 - 副本.jpeg)

![d915908626573eaed06a170ced4170da](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/d915908626573eaed06a170ced4170da.png)

* `16位`源端口:发送方主机的特定端口号，标识数据的发送者。

* `16位`目的端口：接收方主机的特定端口号，标识数据的接收者。

* `32位`序列号：标记数据流中每个字节的顺序，确保有序传输。

* `32位`确认号：确认接收到的数据，并告知期望接收的下一个字节序号，确保可靠的传输。

* `4位`数据偏移：TCP报文段中数据部分起始位置距离报文段起始处的字节偏移量，用于指示TCP头部的长度，从而确定数据部分的起始位置。

* `6位`保留位：目前未使用，必须全部置为0，预留给未来协议扩展的空间。

* `6位`标志位：

  * URG（紧急位）：指示TCP报文段中是否包含紧急数据，URG=1时表示有紧急数据需要优先处理。

  * ACK（确认位）：指示确认号字段是否有效，ACK=1时表示接收方已成功接收到发送方的数据段。

  * PSH（推送位）：指示接收方是否应立即将数据提交给上层应用，PSH=1时表示应立即交付数据。

  * RST（重置位）：指示是否需要重置TCP连接，RST=1时表示连接出现严重错误，需要重新建立连接。

  * SYN（同步位）：用于在建立连接时同步序号，SYN=1时表示连接请求或连接确认，用于建立连接。

  * FIN（结束位）：指示发送方是否完成数据发送，FIN=1时表示发送方已无数据要发送且请求释放连接。

  ![5279ba0bb380933fe170e9b2a9223510 - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/5279ba0bb380933fe170e9b2a9223510 - 副本.png)

  <img src="https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/image-20250208015440265.png" alt="image-20250208015440265"  />

* `16位`窗口大小：指示接收方TCP接收缓冲区当前可接收的最大数据量，用于流量控制，确保发送方不会发送超过接收方处理能力的数据，从而避免缓存溢出。

* `16位`校验和：用于验证TCP报文段的完整性。发送端计算整个TCP报文段（包括首部和数据）及12字节伪首部的校验和并填入字段，接收端重新计算并比较，若不一致则表明报文在传输过程中出现错误。

* `16位`紧急指针：表示紧急数据相对于TCP报文段数据部分起始位置的偏移量，当URG标志位为1时有效，接收方根据该指针识别并优先处理紧急数据。

* 选项：用于扩展TCP协议功能，长度可变且必须为32位整数倍，最长为40字节，常见选项包括MSS、窗口扩大因子和时间戳，旨在优化TCP连接的性能并适应不同的网络环境。

* 填充：用于补位，使TCP首部长度为4字节的整数倍，确保整个首部结构对齐。

* 数据：TCP报文的有效负载部分，携带应用层数据。无数据的TCP段也合法，用于确认和控制信息。

#### 4.握手挥手

![8e1355bc70c91dd3c6e4affdb9c1a9bf - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/8e1355bc70c91dd3c6e4affdb9c1a9bf - 副本.png)

#### 三次握手（建立连接）

![f5c266e57582d19faf528629deeac7f4 - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/f5c266e57582d19faf528629deeac7f4%20-%20%E5%89%AF%E6%9C%AC.png)

![850de5c566ae60989f45cff4b1aad94c - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/850de5c566ae60989f45cff4b1aad94c - 副本.png)

* **握手过程：**

  **1）简化：**

  * **第一次握手**：客户端发送`SYN=1, seq=x` → 服务端进入`SYN-RCVD`  

  * **第二次握手**：服务端回复`SYN=1, ACK=1, seq=y, ack=x+1` → 客户端进入`SYN-SENT`  

  * **第三次握手**：客户端发送`ACK=1, ack=y+1` → 双方进入`ESTABLISHED`  

  **2）详细：**

  * **第一次握手**：客户端发送SYN请求并带有初始序列号（seq=x）。

  * **第二次握手**：服务器收到SYN报文后，发送SYN+ACK报文，确认连接请求，并发送自己的序列号（seq=y），确认号（ack=x+1）。

  * **第三次握手**：客户端收到SYN+ACK报文后，向服务器发送ACK报文，确认服务器的连接请求，并发送确认号（ack=y+1），完成连接建立。

* **握手目的**：三次握手的目的是为了确认客户端和服务器的接收与发送能力是否正常，并同步序列号以确保数据传输有序。

  * **第一次握手**：确认客户端的发送能力，确保客户端可以向服务器发送数据。

  * **第二次握手**：确认服务器的接收与发送能力，确保服务器能够接收客户端的数据并发送确认信息。

  * **第三次握手**：确认客户端的接收能力，确保客户端可以接收服务器的数据并完成连接的建立。

#### 四次挥手（释放连接）![ae6ae19a2f06e0644935471cc5dee027 - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/ae6ae19a2f06e0644935471cc5dee027 - 副本.png)![0dc25c2e6ae3de02cc4039553165d8cf - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/0dc25c2e6ae3de02cc4039553165d8cf - 副本.png)

* **挥手过程**：

  **1）简化：**

  * **第一次挥手**：客户端发送`FIN=1, seq=u` → 进入`FIN-WAIT-1`  

  * **第二次挥手**：服务端回复`ACK=1, ack=u+1` → 进入`CLOSE-WAIT`  

  * **第三次挥手**：服务端发送`FIN=1, seq=v` → 进入`LAST-ACK`  

  * **第四次挥手**：客户端回复`ACK=1, ack=v+1` → 进入`TIME-WAIT`等待**2MSL**后关闭  

  **2）详细：**

  * **第一次挥手**：客户端发送FIN报文，表示停止数据发送，进入FIN_WAIT_1状态。

  * **第二次挥手**：服务器收到FIN报文后，发送ACK报文，确认关闭请求，并进入CLOSE_WAIT状态。

  * **第三次挥手**：服务器发送FIN报文，表示服务器端的数据传输完毕，进入LAST_ACK状态。

  * **第四次挥手**：客户端收到FIN报文后，发送ACK报文确认，并进入TIME_WAIT状态，等待2MSL后进入CLOSED状态。

* **挥手目的**：四次挥手的目的是确保双向数据传输都已完成，允许双方独立地关闭各自的连接，确保每一方向的连接都能可靠地终止。

  * **第一次挥手**：客户端发起连接释放，停止发送数据，表示希望关闭连接。

  * **第二次挥手**：服务器确认客户端停止数据发送，准备关闭连接。

  * **第三次挥手**：服务器确认自己的数据发送完毕，准备完全关闭连接。

  * **第四次挥手**：客户端确认服务器关闭请求，确保双方都完成连接释放。

#### TIME-WAIT状态原因

- 确保最后一个ACK到达服务端  
- 防止旧连接报文干扰新连接  

TIME-WAIT状态的原因是确保客户端发送的最后一个ACK报文能够到达服务器，并防止已失效的连接请求报文影响新的连接。客户端在此状态等待2MSL（最长报文段寿命）时间，以确保所有报文都已从网络中消失，并能重传丢失的ACK报文。

#### 通俗理解

* **三次握手的过程（比喻：打电话）**

  想象你打电话给朋友：

  * **第一次握手（拨打电话）**：
    你拨打电话说：“嗨，我想和你聊聊。”
    就像客户端发出连接请求（SYN），希望建立连接。

  * **第二次握手（接电话）**：
    朋友接电话回应：“我收到了，咱们可以聊。”
    服务器收到请求后回复确认（SYN+ACK），表示准备好接收并发送数据。

  * **第三次握手（确认通话）**：
    你说：“好的，我能听到你，咱们开始聊。”
    客户端最终确认服务器已准备好，建立了连接（ACK）。此时，通话可以正式开始。

* **四次挥手的过程（比喻：挂电话）**

  当聊天结束，准备挂电话时：

  * **第一次挥手（客户端挂电话）**：
    你说：“好了，我要挂电话了。”
    客户端告诉服务器它不再发送数据（FIN），但仍能接收数据。

  * **第二次挥手（服务器回应）**：
    朋友回应：“好的，我知道你挂电话了。”
    服务器确认客户端的挂断请求（ACK），并准备关闭连接。

  * **第三次挥手（服务器挂电话）**：
    朋友说：“我也准备挂电话了。”
    服务器发出挂断请求（FIN），并表示自己也没有数据要发送。

  * **第四次挥手（客户端确认）**：
    你说：“我确认你挂电话了。”
    客户端确认服务器挂断（ACK），进入TIME-WAIT状态，确保所有数据传输完成。

**TIME-WAIT状态原因**

就像打电话时稍等几秒确认对方已挂断。TIME-WAIT确保客户端确认的ACK到达服务器，且确保未发送的报文被丢弃，避免影响新连接。

**总结**

三次握手确保连接建立，四次挥手确保连接完整、安全地断开。

### 四.HTTP初识

#### 1.报文结构

![6f7cbe2d49c170624d5a8776b2db5997 - 副本](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/6f7cbe2d49c170624d5a8776b2db5997 - 副本.png)

#### ![httpmessage](https://raw.githubusercontent.com/ZhouQuan-7237/image-bed/main/httpmessage.jpg)

* **请求报文结构**

  **1）简略**：

  - **请求行**：方法（GET/POST）、URL、协议版本（如`HTTP/1.1`）  

  - **请求头**：附加信息（如`Host`、`User-Agent`、`Cookie`、`Content-Type`）  

  - **请求体**：POST请求的数据（如表单内容）  

    **关键差异**：  

  - **GET**：参数在URL中，无请求体  

  - **POST**：数据在请求体中，支持大体积传输 

  **2）详细**：

  * **请求行**：由请求方法、请求URI和HTTP协议版本三个部分组成，

    ​	格式为：`Method Request-URI HTTP-Version`，比如：`GET /index.html HTTP/1.1`。

    ​	作用是：明确客户端向服务器请求的操作类型、资源路径以及所使用的HTTP协议版本。

    * **请求方法**：指定客户端希望服务器对资源执行的操作。

      | 方法    | 定义                     | 描述                                                         |
      | ------- | ------------------------ | ------------------------------------------------------------ |
      | GET     | 获取指定资源             | 向服务器请求并获取资源，参数通常附加在 URL 中。              |
      | POST    | 提交数据到指定资源       | 向服务器发送数据（如表单数据或文件上传），通常会导致资源的创建或修改。 |
      | PUT     | 上传数据到指定资源       | 将数据上传到服务器并更新指定资源，若资源不存在则创建新资源。 |
      | DELETE  | 删除指定资源             | 请求删除服务器上的指定资源。                                 |
      | HEAD    | 获取资源的元信息         | 类似GET，但只返回响应头，不返回资源的实际内容，用于获取资源的元信息（如是否存在）。 |
      | OPTIONS | 查询服务器支持的请求方法 | 返回服务器针对特定资源所支持的 HTTP 请求方法。               |
      | TRACE   | 回显服务器收到的请求     | 回显服务器收到的请求，主要用于诊断和调试。                   |
      | CONNECT | 建立隧道连接             | 建立与服务器的隧道连接，常用于HTTPS等加密连接的代理服务。    |

    * **请求URL**（统一资源定位符）:指定请求资源的位置，包含协议（如HTTP）、主机地址、端口（可选）、路径和查询字符串。

      基本格式如下：

      ```
      <协议>://<主机>:<端口>/<路径>?<查询字符串> 
      ```

      - **协议**：如http或https。
      - **主机**：请求的服务器地址，如www.example.com。
      - **端口**：可选，指定端口号，默认HTTP为80，HTTPS为443。
      - **路径**：请求的资源路径。
      - **查询字符串**：可选，包含请求参数。

    * **HTTP协议版本**:指定客户端和服务器之间使用的通信协议版本，

      常见的有：HTTP/1.0,HTTP/1.1**：**HTTP/2。

* **响应报文结构**

  **1）简略：**

  - **状态行**：协议版本、状态码（如`200 OK`、`404 Not Found`）、状态描述  
  - **响应头**：服务端信息（如`Server`、`Content-Type`、`Set-Cookie`）  
  - **响应体**：返回的数据（HTML、JSON等）  

  **2）详细：**

  * **状态行**：由HTTP协议版本、状态码和状态码描述三个部分组成，

    ​	格式为：`HTTP-Version Status-Code Reason-Phrase CRLF`,比如：`HTTP/1.1 200 OK`

    ​	作用是：指示客户端关于请求处理的基本信息。

    * **HTTP协议版本**:指定客户端和服务器之间使用的通信协议版本，

      常见的有：HTTP/1.0,HTTP/1.1**：**HTTP/2。

    * **状态码**：三位数字代码，表示服务器对客户端请求的处理结果。

      分为五类：

      - **1xx**（信息性）：表示请求已接收，需继续处理。
      - **2xx**（成功）：表示请求已成功处理。
      - **3xx**（重定向）：表示请求需进一步操作才能完成。
      - **4xx**（客户端错误）：表示客户端请求无效或存在错误。
      - **5xx**（服务器错误）：表示服务器处理请求时出现错误。

    * **状态码描述**：对状态码的简要描述，提供状态码的具体含义。

      | **状态码** | **英文名称**                    | **中文描述**                                               |
      | ---------- | ------------------------------- | ---------------------------------------------------------- |
      | **1xx**    | **信息性状态码**                |                                                            |
      | 100        | Continue                        | 请求已接收，客户端应继续其请求。                           |
      | 101        | Switching Protocols             | 服务器根据客户端的请求切换协议，只能切换到更高级协议。     |
      | **2xx**    | **成功状态码**                  |                                                            |
      | 200        | OK                              | 请求成功，服务器已正常处理请求。                           |
      | 201        | Created                         | 请求成功并创建了新的资源。                                 |
      | 202        | Accepted                        | 请求已被接受，但尚未处理。                                 |
      | 203        | Non-Authoritative Information   | 请求成功，但返回的meta信息来自副本而非原始服务器。         |
      | 204        | No Content                      | 请求成功，服务器无内容返回。                               |
      | 205        | Reset Content                   | 服务器处理成功，用户终端应重置文档视图。                   |
      | 206        | Partial Content                 | 服务器成功处理了部分GET请求，返回指定范围的内容。          |
      | **3xx**    | **重定向状态码**                |                                                            |
      | 300        | Multiple Choices                | 请求的资源有多个选择，客户端需选择一个。                   |
      | 301        | Moved Permanently               | 请求的资源已被永久转移到新的URI，客户端应使用新的URI。     |
      | 302        | Found                           | 请求的资源已临时转移到新的URI，客户端继续使用原URI。       |
      | 303        | See Other                       | 资源存在另一个URI，客户端应使用GET方法访问该URI。          |
      | 304        | Not Modified                    | 请求的资源未修改，服务器返回此状态码时不包含资源。         |
      | 305        | Use Proxy                       | 请求的资源必须通过代理访问。                               |
      | 306        | Unused                          | 已废弃的HTTP状态码。                                       |
      | 307        | Temporary Redirect              | 临时重定向，服务器要求客户端使用GET请求重新发送请求。      |
      | **4xx**    | **客户端错误状态码**            |                                                            |
      | 400        | Bad Request                     | 请求语法错误，服务器无法理解。                             |
      | 401        | Unauthorized                    | 请求需要用户身份认证。                                     |
      | 402        | Payment Required                | 保留状态，未来使用。                                       |
      | 403        | Forbidden                       | 服务器理解请求，但拒绝执行该请求。                         |
      | 404        | Not Found                       | 请求的资源未找到，服务器无法根据请求路径找到资源。         |
      | 405        | Method Not Allowed              | 请求中的HTTP方法被禁止。                                   |
      | 406        | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求。               |
      | 407        | Proxy Authentication Required   | 请求要求通过代理进行认证。                                 |
      | 408        | Request Time-out                | 请求超时，服务器等待客户端请求超时。                       |
      | 409        | Conflict                        | 请求的资源冲突，服务器无法处理。                           |
      | 410        | Gone                            | 请求的资源已被永久删除。                                   |
      | 411        | Length Required                 | 请求缺少Content-Length头部，服务器无法处理。               |
      | 412        | Precondition Failed             | 请求的先决条件错误                                         |
      | 413        | Request Entity Too Large        | 请求实体过大，服务器无法处理。                             |
      | 414        | Request-URI Too Large           | 请求的URI过长，服务器无法处理。                            |
      | 415        | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                           |
      | 416        | Requested Range Not Satisfiable | 客户端请求的范围无效。                                     |
      | 417        | Expectation Failed              | 服务器无法满足Expect的请求头信息                           |
      | 418        | I'm a teapot                    | 作为愚人节玩笑，服务器回应此状态码。                       |
      | **5xx**    | **服务器错误状态码**            |                                                            |
      | 500        | Internal Server Error           | 服务器内部错误，无法完成请求。                             |
      | 501        | Not Implemented                 | 服务器不支持请求的功能，无法完成请求。                     |
      | 502        | Bad Gateway                     | 充当网关或代理服务器时，从远端服务器接收到了一个无效的请求 |
      | 503        | Service Unavailable             | 服务器超载或正在维护，暂时无法处理请求。                   |
      | 504        | Gateway Time-out                | 充当网关或代理服务器时，未能及时从远程服务器获取请求。     |
      | 505        | HTTP Version Not Supported      | 服务器不支持请求中使用的HTTP协议版本。                     |

  * **响应头**：包含服务器返回的元信息，比如：服务器环境信息、响应体的大小、服务器支持的压缩类型等

    常见响应头：

    - `Cache-Control`：控制缓存的行为。
    - `Content-Type`：指示实体的媒体类型。
    - `Content-Length`：指示实体的大小（单位：字节）。
    - `Server`：提供服务器的安装信息。
    - `Set-Cookie`：设置客户端的 Cookie 信息。

  * **空白行**：用于分隔响应头和响应体，标志着响应头的结束。

  * **响应体**：服务器返回给客户端的实际数据内容，如HTML、图片、JSON等。

    ​	      响应体是可选的，如果服务器没有数据返回，响应体可以为空。

#### 2.请求/响应

```
用户输入URL → DNS解析 → TCP三次握手 → 发送HTTP请求 → 服务器响应 →
解析HTML并加载资源 → 渲染页面 → TCP四次挥手
```

**1）DNS解析**：浏览器通过DNS将URL中的域名解析为IP地址，定位目标服务器。

**解析顺序**：浏览器缓存 → 操作系统缓存 → 路由器缓存 → 本地DNS服务器 → 根DNS递归查询。

**2）建立TCP连接（三次握手）**：客户端与服务器通过TCP三次握手建立连接，确保可靠通信。

**3）发送HTTP请求**：客户端通过TCP连接向服务器发送HTTP请求报文。

**4）服务器处理请求并返回响应**：服务器接收请求并进行处理，生成响应报文返回给客户端。

**5） 浏览器解析并加载资源**：浏览器解析响应的HTML代码，提取所需资源（如CSS、JS、图片等），并发起额外的请求。

**6） 页面渲染**：浏览器结合HTML和静态资源渲染页面并展示给用户。

**7） 断开TCP连接（四次挥手）**：客户端与服务器通过TCP四次挥手断开连接，释放资源。

## 参考资料

请查阅阶段六任务计划思路